[env:esp32dev]
platform = espressif32
board = esp32dev
framework = arduino
monitor_speed = 115200
lib_deps =
    bodmer/TFT_eSPI
    miguelbalboa/MFRC522@^1.4.10
    bblanchon/ArduinoJson@^7.0.4
build_flags =
    -D USER_SETUP_LOADED
    -D ILI9341_DRIVER
    -D SPI_FREQUENCY=20000000
    -D TFT_MISO=19
    -D TFT_MOSI=23
    -D TFT_SCLK=18
    -D TFT_CS=22
    -D TFT_DC=17
    -D TFT_RST=21
    -D TFT_BL=16
    -D LOAD_GLCD
    -D LOAD_FONT2
    -D LOAD_FONT4
    -D LOAD_FONT7
    -D LOAD_FONT8
    -D LOAD_GFXFF









#include <Arduino.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <WiFiClientSecure.h> // Wichtig für HTTPS
#include <SPI.h>
#include <MFRC522.h>
#include <ArduinoJson.h>
#include <TFT_eSPI.h>
#include <SD.h>
#include <FS.h>
#include "mbedtls/md.h"

// --- 1. KONFIGURATION (ANPASSEN!) ---
const char* ssid = "MagentaWLAN-29Q3";
const char* password = "Esenha2022#";

// ZIEL: Die Cloud! (HTTPS)
const char* serverName = "https://ahmtimus.com/api/v1/stamp"; 

// DEVICE SECRET (Muss exakt mit deiner .env auf dem Server übereinstimmen!)
const char* device_secret = "MEIN_GEHEIMES_DEVICE_PASSWORT";
const String SD_SECRET = "AHMTIMUS_SECURE_KEY_2025";

// --- 2. HARDWARE PINS ---
#define MFRC522_RST_PIN 4
#define MFRC522_SS_PIN 5
#define AHMTIMUS_BLUE 0x19B1

MFRC522 mfrc522(MFRC522_SS_PIN, MFRC522_RST_PIN);
TFT_eSPI tft = TFT_eSPI();
SPIClass sdSPI(HSPI);

String lastCardId = "";
unsigned long lastSendTime = 0;
char timeBuffer[6];
char dateBuffer[40];
char lastTimeBuffer[6] = "";

const char* daysOfWeek[7] = {"Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"};
const char* monthsOfYear[12] = {"Januar", "Februar", "Maerz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"};

// --- HELPER ---
String encryptDecrypt(String input) {
    char key[SD_SECRET.length() + 1];
    SD_SECRET.toCharArray(key, sizeof(key));
    String output = input;
    for (int i = 0; i < input.length(); i++) output[i] = input[i] ^ key[i % (sizeof(key) - 1)];
    return output;
}

String createHMAC(String data, const char* key) {
    byte hmacResult[32];
    mbedtls_md_context_t ctx;
    mbedtls_md_type_t md_type = MBEDTLS_MD_SHA256;
    mbedtls_md_init(&ctx);
    mbedtls_md_setup(&ctx, mbedtls_md_info_from_type(md_type), 1);
    mbedtls_md_hmac_starts(&ctx, (const unsigned char *) key, strlen(key));
    mbedtls_md_hmac_update(&ctx, (const unsigned char *) data.c_str(), data.length());
    mbedtls_md_hmac_finish(&ctx, hmacResult);
    mbedtls_md_free(&ctx);
    String hash = "";
    for(int i=0; i<32; i++){
        if(hmacResult[i] < 16) hash += "0";
        hash += String(hmacResult[i], HEX);
    }
    return hash;
}

void saveToSD(String cardId, String timestamp, String type) {
    if(SD.cardType() == CARD_NONE) return;
    File file = SD.open("/system.dat", FILE_APPEND);
    if(file) {
        JsonDocument doc;
        doc["cid"] = cardId; doc["ts"] = timestamp; doc["t"] = type;
        String jsonString; serializeJson(doc, jsonString);
        file.println(encryptDecrypt(jsonString));
        file.close();
    }
}

// --- DISPLAY (Finales Layout) ---
void displayResult(String line1, String line2, uint16_t color) {
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(color);
    tft.setFreeFont(&FreeSansBold18pt7b);
    tft.setTextDatum(TC_DATUM);
    tft.drawString(line1, tft.width() / 2, 70);
    tft.setTextFont(4);
    tft.setTextDatum(BC_DATUM);
    tft.drawString(line2, tft.width() / 2, tft.height() - 70);
    tft.setTextFont(1);
}

void displayProcessing() {
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_DARKGREEN);
    tft.setTextDatum(MC_DATUM);
    tft.setTextFont(4);
    tft.drawString("Verbinde...", tft.width()/2, tft.height()/2);
}

void displayLayout() {
    tft.fillScreen(TFT_BLACK);
    tft.setTextDatum(BL_DATUM);
    tft.setTextColor(AHMTIMUS_BLUE);
    tft.setTextFont(2);
    tft.drawString("AHMTIMUS (C)", 10, tft.height() - 10);
    
    struct tm timeinfo;
    if (getLocalTime(&timeinfo)) {
        // Datum unten
        sprintf(dateBuffer, "%s, %d. %s", daysOfWeek[timeinfo.tm_wday], timeinfo.tm_mday, monthsOfYear[timeinfo.tm_mon]);
        tft.setTextColor(TFT_WHITE, TFT_BLACK);
        tft.setTextDatum(MC_DATUM);
        tft.setFreeFont(&FreeSans9pt7b);
        tft.drawString(dateBuffer, tft.width() / 2, 133); 
        
        // Uhrzeit oben (Abstand zum Datum!)
        strftime(timeBuffer, sizeof(timeBuffer), "%H:%M", &timeinfo);
        tft.setTextFont(8);
        tft.setTextColor(TFT_WHITE, TFT_BLACK);
        tft.drawString(timeBuffer, tft.width() / 2, 70); 
        strcpy(lastTimeBuffer, timeBuffer);
    }
    
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setTextFont(4);
    tft.setTextDatum(MC_DATUM);
    tft.drawString("Bitte Karte auflegen", tft.width() / 2, tft.height()/2 + 60);
}

// --- SENDEN (HTTPS CLOUD) ---
void sendStampToServer(String cardId) {
    displayProcessing();
    
    struct tm timeinfo;
    getLocalTime(&timeinfo);
    time_t now; time(&now);
    String timestamp = String((unsigned long)now);
    
    saveToSD(cardId, timestamp, "ATTEMPT");

    if (WiFi.status() != WL_CONNECTED) {
        displayResult("Offline", "Gespeichert", TFT_ORANGE);
        delay(2000); displayLayout(); return;
    }

    // SSL CLIENT
    WiFiClientSecure client;
    client.setInsecure(); // Wir vertrauen dem Zertifikat (Wichtig für Cloud!)
    
    HTTPClient http;
    
    Serial.print("Verbinde zu: ");
    Serial.println(serverName);

    if (!http.begin(client, serverName)) {
        displayResult("Server weg", "Lokal gesichert", TFT_RED);
        delay(2000); displayLayout(); return;
    }

    http.addHeader("Content-Type", "application/json");

    String nonce = String(random(1000000));
    String payloadData = cardId + ":" + timestamp + ":" + nonce;
    String signature = createHMAC(payloadData, device_secret);

    JsonDocument doc;
    doc["cardId"] = cardId; doc["timestamp"] = timestamp; doc["nonce"] = nonce; doc["signature"] = signature;
    String jsonPayload; serializeJson(doc, jsonPayload);

    int httpResponseCode = http.POST(jsonPayload);
    
    if (httpResponseCode > 0) {
        String payload = http.getString();
        Serial.println("Antwort: " + payload);

        if (httpResponseCode == 200) {
            JsonDocument docResponse;
            deserializeJson(docResponse, payload);
            const char* user = docResponse["user"];
            const char* type = docResponse["type"];
            
            uint16_t color = (String(type) == "Kommen") ? TFT_GREEN : TFT_ORANGE;
            // Uhrzeit aus Buffer für Anzeige
            String displayTime = String(timeBuffer); 
            displayResult(String(user), String(type) + " " + displayTime, color);
        } else {
            JsonDocument docResponse;
            deserializeJson(docResponse, payload);
            String msg = docResponse["message"];
            displayResult("Abgelehnt", msg, TFT_RED);
        }
    } else {
        Serial.print("HTTP Error: ");
        Serial.println(httpResponseCode);
        displayResult("Fehler", "Verbindung", TFT_RED);
    }
    http.end();
    delay(2500);
    displayLayout();
}

void setup() {
    Serial.begin(115200);
    tft.init(); tft.setRotation(1); tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_WHITE); tft.setTextDatum(MC_DATUM); tft.setTextFont(4);
    tft.drawString("Cloud Sync...", tft.width()/2, tft.height()/2);

    sdSPI.begin(14, 27, 13, 26);
    SD.begin(26, sdSPI, 4000000);

    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED) { delay(500); Serial.print("."); }
    
    configTime(3600, 3600, "pool.ntp.org");
    struct tm timeinfo; getLocalTime(&timeinfo);

    SPI.begin(); mfrc522.PCD_Init();
    displayLayout();
}

void loop() {
    static unsigned long lastTime = 0;
    if(millis() - lastTime > 1000) {
        lastTime = millis();
        struct tm timeinfo;
        if(getLocalTime(&timeinfo)) {
            strftime(timeBuffer, sizeof(timeBuffer), "%H:%M", &timeinfo);
            if(strcmp(timeBuffer, lastTimeBuffer) != 0) {
                // Layout Refresh: Lösche nur Bereich oben (Uhr) und male neu
                tft.fillRect(0, 30, tft.width(), 80, TFT_BLACK); 
                tft.setTextColor(TFT_WHITE, TFT_BLACK);
                tft.setTextDatum(MC_DATUM);
                tft.setTextFont(8); 
                tft.drawString(timeBuffer, tft.width() / 2, 80); 
                strcpy(lastTimeBuffer, timeBuffer);
                // Datum sicherheitshalber neu malen (unten)
                sprintf(dateBuffer, "%s, %d. %s", daysOfWeek[timeinfo.tm_wday], timeinfo.tm_mday, monthsOfYear[timeinfo.tm_mon]);
                tft.setFreeFont(&FreeSans9pt7b);
                tft.drawString(dateBuffer, tft.width() / 2, 133); 
                tft.setTextFont(1);
            }
        }
    }

    if (!mfrc522.PICC_IsNewCardPresent()) return;
    if (!mfrc522.PICC_ReadCardSerial()) return;

    String cardId = "";
    for (byte i = 0; i < mfrc522.uid.size; i++) {
        if (mfrc522.uid.uidByte[i] < 0x10) cardId += "0";
        cardId += String(mfrc522.uid.uidByte[i], HEX);
    }
    cardId.toUpperCase();
    
    if (cardId == lastCardId && (millis() - lastSendTime) < 4000) { } 
    else {
        Serial.println("Sende an Cloud: " + cardId);
        sendStampToServer(cardId);
        lastCardId = cardId;
        lastSendTime = millis();
    }
    mfrc522.PICC_HaltA();
    mfrc522.PCD_StopCrypto1();
}